<!DOCTYPE html>
<html>
	<head>
			<meta charset="utf-8">
		<title>History of programming languages</title>
						<style>p{color:blue}</style>

	</head>
	<body style="margin: 0;background-color:antiquewhite;">
		<h1 style="text-align: center;background-color:antiquewhite;">History of programming languages</h1>
		<div style="background-color:antiquewhite;">
		<a href="index.html" target="_blank" style="font-size:200%"> Home page</a><br>
		<a href="history.html" target="_blank" style="font-size:200%"> History of programming languages</a><br>
		<a href="Properties of Programming language.html" target="_blank" style="font-size:200%"> Characters of Programming languages</a><br>
		<a href="uses of programming language.html" target="_blank" style="font-size:200%"> uses of programming languages</a><br>
		<a href="types of programming language.html" target="_blank" style="font-size:200%"> types of Programming language</a><br>
		<p1 style="font-size:150%"> Before 1940</p1>
		<p>The first programming languages predate the modern computer. At first, the languages were codes. During a nine-month period in 1842-1843, Ada Lovelace translated Italian mathematician Luigi Bernoulli numbers with the Engine, recognized by some historians as the world's first computer program. The first computer codes were specialized for the applications. Like many «firsts» in history, the first modern programming language is hard to identify. From the start, the restrictions of the hardware defined the language. The use of a magnetic drum for memory meant that computer programs also had to be interleaved with the rotations of the drum. To some people the answer depends on how much power and human-readability is required before the status of «programming language» is granted. Difference Engine both had simple, extremely limited languages for describing the actions that these machines should perform. One can even regard the punch holes on a player piano scroll as a limited domain-specific language, albeit not designed for human consumption.</p>
		<p1 style="font-size:150%">The 1940s</p1>
		<p>In the 1940s the first recognizably modern, electrically powered computers were created. The limited speed and memory capacity forced programmers to write hand tuned assembly language programs. It was soon discovered that programming in assembly language required a great deal of intellectual effort and was error-prone.</p>
		<p1 style="font-size:150%"> The 1950s and 1960s</p1>
		<p>In the 1950s the first three modern programming languages whose descendants are still in widespread use today were designed Committee, heavily influenced by Grace Hopper. Another milestone in the late 1950s was the publication, by a committee of American and a mathematically exact notation, Backus–Naur Form , was used to describe the language's syntax. Algol 60 was particularly influential in the design of later languages, some of which soon became more popular. The Burroughs large systems were designed to be programmed in an extended subset of Algol.</p>
		<p1 style="font-size:150%">1967-1978: establishing fundamental paradigms</p1>
		<p>The period from the late 1960s to the late 1970s brought a major flowering of programming languages. Simula, invented in the late 1960s by Nygaard and Dahl as a superset of Algol 60, was the first language designed to support object-oriented programming. Prolog, designed in 1972 by Colmerauer, Roussel, and Kowalski, was the first logic programming language. ML built a polymorphic type system on top of Lisp, pioneering statically typed functional programming languages. Although the debate raged hotly at the time, nearly all programmers now agree that, even in languages that provide GOTO, it is bad programming style to use it except in rare circumstances.</p>
		<p1 style="font-size:150%"> The 1980s: consolidation, modules, performance</p1>
		<p>The 1980s were years of relative consolidation. C++ combined object-oriented and systems programming. The United States government standardized Ada, a systems programming language intended for use by defense contractors. In Japan and elsewhere, vast sums were spent investigating so-called fifth-generation programming languages that incorporated logic programming constructs. The functional languages community moved to standardize ML and Lisp. Rather than inventing new paradigms, all of these movements elaborated upon the ideas invented in the previous decade. The RISC movement in computer architecture postulated that hardware should be designed for compilers rather than for human assembly programmers. Aided by processor speed improvements that enabled increasingly aggressive compilation techniques, the RISC movement sparked greater interest in compilation technology for high-level languages.</p>
		<p1 style="font-size:150%"> The 1990s: the Internet age</p1>
		<p>The 1990s saw no fundamental novelty, but much recombination as well as maturation of old ideas. A big driving philosophy was programmer productivity. Many "rapid application development" (RAD) languages emerged, which usually came with an IDE, garbage collection, and were descendants of older languages. All such languages were object-oriented. These included Object Pascal, Visual Basic, and C#. Java was a more conservative language that also featured garbage collection and received much attention. More radical and innovative than the RAD languages were the new scripting languages. These did not directly descend from other languages and featured new syntaxes and more liberal incorporation of features. Many consider these scripting languages to be more productive than even the RAD languages, but often because of choices that make small programs simpler but large programs more difficult to write and maintain. [citation needed] Nevertheless, scripting languages came to be the most prominent ones used in connection with the Web</p>
		<p1 style="font-size:150%">Current trends</p1>
		<p>Programming language evolution continues, in both industry and research. Some of the current trends include:
		<p>1- Mechanisms for adding security and reliability verification to the language: extended static checking, information flow control, static thread safety.</p>
		<p>2- Alternative mechanisms for modularity: mixins, delegates, aspects.</p>
		<p>3- Component-oriented software development.</p>
		<p>4- Metaprogramming, reflection or access to the abstract syntax tree</p>
		<p>5- Increased emphasis on distribution and mobility.</p>
		<p>6- Integration with databases, including XML and relational databases.</p>
		<p>7- Support for Unicode so that source code (program text) is not restricted to those characters contained in the ASCII character set; allowing, for example, use of non-Latin-based scripts or extended punctuation.</p>
		<p>8- XML for graphical interface (XUL, XAML). </p>
		
	</body>
</html>